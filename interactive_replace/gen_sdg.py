"""
This file generates the Signal Dependency Graph (SDG).
How to run this script?
    $ python gen_sdg.py <name of the cdfg file> <name of the module> <name of the signal>
    Eg: $ python gen_sdg.py cdfg_mips_core_20.txt mips_core NET21531 |& tee out.log

Note:
* You don't need to do any copying of CDFG form ../gen_cdfg folder.\
        # It's taken care in this script. 
"""

#TODO
"""
* Add instance names in the graph (instead of just the module names).
* There are some extra nodes in the SDG due to the bug (possibly) in \
        write_dot function which introduces nodes with names as part of the existing names. 
* The correctness of the graph in breq_fifos with four different basic_fifos
* Try visualizing the graph using matplotlib as NetworkX will soon discontinue \
        it's plotting options suppessing numpy warnings. 
"""

# FUTURE IMPROVEMENTS
"""
* Before starting the process (right from parse_verilog), write a script to save\
        all module declarations in separate files if they are found in same file.
* Exit with error message if the returned value (after the pattern matchings) is an empty list\
        in the function find_mapped_module. 
"""

import sys
import os
import re
from antlr4 import *
from quteRTL_cdfgLexer import quteRTL_cdfgLexer
from quteRTL_cdfgParser import quteRTL_cdfgParser
from quteRTL_cdfgMyVisitor import quteRTL_cdfgMyVisitor
from functions import *
import networkx as nx
from networkx.drawing.nx_agraph import *
from matplotlib import *
import time
from shutil import copyfile

#------------------------------------------------------------------
# Imports for creating .dot file
try:
    import pygraphviz
    from networkx.drawing.nx_agraph import write_dot
    if(DBG): print("using package pygraphviz")
except ImportError:
    try:
        import pydot
        from networkx.drawing.nx_pydot import write_dot
        if(DBG): print("using package pydot")
    except ImportError:
        if(DBG): print()
        if(DBG): print("Both pygraphviz and pydot were not found ")
        if(DBG): print("see  https://networkx.github.io/documentation/latest/reference/drawing.html")
        if(DBG): print()
        raise
#------------------------------------------------------------------

# Constants
DBG = 0 # to print the output of the execution on screen.

# Paths and files
tmpDir = 'tmp/'
dotDir = 'out/dot_files/'
cdfgDir = '../gen_cdfg/cdfg/'
# TODO Uncomment
cdfgNoHeaders = 'cdfg_no_headers/'
cdfgProcessed = 'cdfg_processed/'
cdfgFiles = 'tmp/cdfgFiles.txt'
cdfgFilesProcessed = 'tmp/cdfgFilesProcessed.txt'
logFile = 'tmp/run.log'
parser_output_list = 'tree_1.txt'
input_list = 'deleteMe.txt'
legacy1 = "legacy/cdfg_counter.txt"
modNamesDir = '../gen_cdfg/tmp/moduleNames/'
# Files with module information.
modInfoFiles = '../gen_cdfg/tmp/modInfo.txt'
# Full module and portMap information with 'in' and 'out' specified in it.
# [ver_file_name, module_name, [<in/out,sig_name>]*]
moduleInfo = '../parse_verilog/out/moduleInfo.txt'
# [ver_file_name, module_name, module_inst_name,[<in/out,sig_name,sig_mapped_to>]*]
portMap = '../parse_verilog/out/portMap.txt'
# File with the names of all Verilog files
verFiles = '../parse_verilog/tmp/verFiles.txt'

# Root signal for finding cone.
#root_sig = "shift_out" #TODO

# Global declarations
l_moduleInfo = []
l_portMap = []

# Clean up files from previous run 
if(DBG): print '\n\n\nCleaning up'
"""delDir(tmpDir)
delDir(cdfgProcessed)
delDir(cdfgNoHeaders)"""

# Create some directories
if(DBG): print 'Creating directories'
createDir(tmpDir)
createDir(cdfgNoHeaders)
createDir(cdfgProcessed)
createDir(dotDir) 

# TODO Assumption for maximum length of the list file generated by Antlr.
# Change it if needed.
MAX_LEN_LIST_FILE = 100000000

# A copy of the edited cdfg_mesi_isc_basic_fifo.txt is kept in bak/
PROCESS_CDFG = 1 
PARSE_ALL = 1 # TODO Keep it 1, when you need to parse all CDFGs 

# Dictionary with information of edges in SDG.
dict_sdg_edges = {}

def main(argv):

    # Test (delete later)
    """paths_with_len = [([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],15), (['a' ,'b' ,'c' ,'d' ,'e' ,'f' ,'g' ,'h' ,'i' ,'j' ,'k' ,'l' ,'m' ,'n' ,'o'],15)]
    no_of_wp = 2
    no_of_sigs_in_wp_cluster = 3
    get_waypoints (paths_with_len, no_of_wp, no_of_sigs_in_wp_cluster)
    exit("Exiting with dignity")"""
    
    # Input ports in SDG
    in_ports_in_sdg = [] 
    # Get the list of CDFGs
    c = 'ls ' + cdfgDir + ' >' + cdfgFiles
    if(DBG): print c+'\n'
    bashComm(c,logFile,DBG)
    
    #------------------------------------------------------------------
    # Processing the cdfg files generated by quteRTL. Steps involved are,
    # 1. Removing headers from the CDFGs generated by the quteRTL
    # 2. Replacing duplicate node numbers in the qutertl with a unused number. 
    # Note: You don't need to do any copying of CDFG form ../gen_cdfg folder.\
            # It's taken care below
    #------------------------------------------------------------------
    # 1. Removing headers from the CDFGs generated by the quteRTL
    if (PROCESS_CDFG):
        if(DBG): print "\n---------------------------------------------------------\n" 
        if(DBG): print "Removing headers from the CDFGs generated by the quteRTL"
        if(DBG): print "\n---------------------------------------------------------\n" 
        start_write = 0
        with open(cdfgFiles, "r") as f1:
                for line1 in f1:
                    #if(DBG): print "line1", line1
                    with open(cdfgNoHeaders + line1.strip(), "w") as f2, open(cdfgDir + line1.strip(), "r") as f3:
                        f2.write(line1)
                        for line2 in f3:
                            pat = re.compile(r'DESIGN @ \w+>')
                            if start_write == 0:
                                if (re.match (pat, line2)):
                                    #if(DBG): print line2
                                    start_write = 1
                            else:
                                #if(DBG): print "Writing line2", line2
                                f2.write(line2)
                    start_write = 0
        # 2. Replacing duplicate node numbers in the qutertl with a unused number. 
        node_list = []
        node_occurance_dict = {}
        with open(cdfgFiles, "r") as f1:
            for line1 in f1:
                #if(DBG): print "line1: ", line1
                with open(cdfgNoHeaders + line1.strip(), "r") as f2:
                    for line2 in f2:
                        match=re.search("\((\d+)\)", line2) 
                        if match:
                            node_list.append(match.groups()[0])
                #if(DBG): print "node_list: ", node_list
                if node_list:
                    largest_node = max(node_list)
                # Initialize node_occurance_dict
                for i in node_list:
                    node_occurance_dict[i] = 0
                if(DBG): print "File under process: ", line1.strip()
                with open(cdfgNoHeaders + line1.strip(), "r") as f2, open(cdfgProcessed + line1.strip(), "w") as f3:
                    replace_count = 0
                    for line2 in f2:
                        match=re.search("\((\d+)\)", line2)
                        if match:
                            if match.groups()[0] in node_occurance_dict:
                                if node_occurance_dict[match.groups()[0]] == 1:
                                    if(DBG): print ("Replacing the node: ", match.groups()[0])
                                    if(DBG): print "line2: ", line2
                                    line2_new = line2.replace(match.groups()[0], largest_node+str(replace_count))
                                    if(DBG): print "line2_new: ", line2_new
                                    replace_count += 1
                                    f3.write(line2_new)
                                else:
                                    node_occurance_dict[match.groups()[0]]=1
                                    f3.write(line2)
                        else:
                            f3.write(line2)
                del node_list[:]
    
    #------------------------------------------------------------------
    # Initializing the dictionary dict_sdg_edges 
    #------------------------------------------------------------------
    with open(verFiles, 'r') as f:
        for line in f:
            dict_sdg_edges[line.strip('\n')] = []
    if(DBG): print "dict_sdg_edges (initialized): ", dict_sdg_edges 

    if (PARSE_ALL):
        #------------------------------------------------------------------
        # Parse using Antlr
        #------------------------------------------------------------------
        if(DBG): print "\n---------------------------------------------------------\n" 
        if(DBG): print "\n Parsing with Antlr"
        if(DBG): print "\n---------------------------------------------------------\n" 
        c = 'ls ' + cdfgProcessed + ' >' + cdfgFilesProcessed
        if(DBG): print c+'\n'
        bashComm(c,logFile,DBG)

    #------------------------------------------------------------------
    # Copy the list generated by the Antlr based parser to a tmp file
    # TODO Eliminate the need for this and directly use the file generated by Antlr.
    #------------------------------------------------------------------
    #c = 'cp ' + parser_output_list + ' ' + input_list 
    #if(DBG)print c+'\n'
    #bashComm(c,logFile,DBG)
    #copyfile(parser_output_list, input_list)
    # TODO Manually copy for now.
    # cp tree_1.txt deleteMe.txt
    #------------------------------------------------------------------
    
    # Get the information of spaces (indentation) along with the node number associated with a line from the quteRTL output.
    #node_dict = white_space_with_node(legacy1)
    #if(DBG)print node_dict

    # Construct the cone from the output of the parser, stored in the file input_list
    if(DBG): print "\n---------------------------------------------------------\n" 
    if(DBG): print "Constructing cone"				
    if(DBG): print "\n---------------------------------------------------------\n" 
   
    #------------------------------------------------------------------
    # Get the moduleInfo and portMap in list form.  
    #------------------------------------------------------------------
    with open(portMap, 'r') as f_p_final, open(moduleInfo, 'r') as f_m_final:
        # Create two lists with the entire contents of moduleInfo and portMap files. 
        for line in f_m_final:
            l_moduleInfo.append(line.strip().split(','))
        for line in f_p_final:
            l_portMap.append(line.strip().split('@'))
    #if(DBG): print "l_moduleInfo: ", l_moduleInfo
    if(DBG): print "l_portMap: ", l_portMap
    
    #------------------------------------------------------------------
    cone = nx.DiGraph()
    in_ports_in_sdg = construct_cone_considering_portmap(sys.argv[1], sys.argv[2], sys.argv[3], cone, None)
    if(DBG): print "in_ports_in_sdg: ",in_ports_in_sdg  
    write_dot(cone, dotDir+"cone.dot")
    leaf_sigs_in_cone_all = ([x for x in cone.nodes() if cone.in_degree(x)==0])
    if(DBG): print "Leaf nodes in the final SDG: ", leaf_sigs_in_cone_all
    #if(DBG)print("Now run: neato -Tps grid.dot >grid.ps") 
    
    #------------------------------------------------------------------
    # SDG Analysis starts here.
    #------------------------------------------------------------------
    # Read the previously stored .dot file
    ENABLED = 0
    if(ENABLED):
        cone_back = read_dot("bak/dot_files/cone_cbus_cmd3_o_mesi_isc.dot")

    #------------------------------------------------------------------
    # Number of incoming edges of all nodes in the cone 
    #------------------------------------------------------------------
    ENABLED = 0 
    if(ENABLED):
        dict_node_and_in_degree = {}
        for x in cone.nodes():
            dict_node_and_in_degree[x] = cone.in_degree(x) 
            if(DBG):print x, ":", cone.in_degree(x)
        if(DBG):print "Edges sorted based on #incoming edges"
        if(DBG):print sorted(dict_node_and_in_degree.items(), key=lambda kv: kv[1], reverse=True)
    #------------------------------------------------------------------

    #------------------------------------------------------------------
    # Printing the longest path
    #------------------------------------------------------------------
    ENABLED = 0 
    if(ENABLED):
        cone.remove_edges_from(cone.selfloop_edges())    
        write_dot (cone, dotDir+"cone_no_self_loop.dot") 
        if(DBG):print nx.dag_longest_path(cone)

    #------------------------------------------------------------------
    # Minimum spanning tree 
    #------------------------------------------------------------------
    ENABLED = 0 
    if(ENABLED):
        G_undirected = cone.to_undirected()
        write_dot (G_undirected, dotDir+"G_undirected.dot")
        T=nx.minimum_spanning_tree(G_undirected)
        print(sorted(T.edges(data=True)))
        write_dot(T, dotDir+"T.dot")

    #------------------------------------------------------------------
    # Find the longest n paths in cone (Success)
    #------------------------------------------------------------------
    ENABLED = 1 
    if(ENABLED):
        root_sig = sys.argv[3]
        cone.remove_edges_from(cone.selfloop_edges())    
        write_dot (cone, dotDir+"cone_no_self_loop_"+"mesi_isc_"+root_sig+".dot")
        no_of_paths = 5
        no_of_wp = 2
        # Should be an odd number.
        no_of_sigs_in_wp_cluster = 3
        #-------------------------
        print "-----n long paths-----"
        t_s = time.time()
        n_long_paths = get_n_long_paths(cone, "mesi_isc_broad."+root_sig, no_of_paths)
        t_e = time.time()
        print "\n run_time(get_n_long_paths): ", t_e-t_s
        #-------------------------
        print "-----waypoints-----"
        waypoints = get_waypoints (n_long_paths, no_of_wp, no_of_sigs_in_wp_cluster)
        print "Waypoints: \n", waypoints 

def call_visitor(file_location):
    """Calls quteRTL_cdfgMyvisitor() function generated by Antlr4
    For example, it can print the module names ports in each module in a Verilog file
    Args: The path to the Verilog file
    Returns: Nothing
    Raises: No error
    """
    input = FileStream(file_location)
    lexer = quteRTL_cdfgLexer(input)
    stream = CommonTokenStream(lexer)
    parser = quteRTL_cdfgParser(stream)
    tree = parser.source_text()
    eval = quteRTL_cdfgMyVisitor()
    eval.visitSource_text(tree)    
    # Testing
    # eval.visitModule_declaration(tree)

    #f1 = quteRTL_cdfgMyVisitor()
    #eval.Test_function()
    #eval.find_in_out_top()
    #eval.write_lists()
    #eval.visitNet_declaration()
    #eval.writeList()

# TODO
#def gen_tree_2 (f_1, f_2):
    """Generate tree_2 from tree_1
    """
    """print f_1
    if(DBG): print f_2
    for line in f_1:
        if(DBG): print 'hi'
        if(DBG): print line
        f_2.write(line)
    return f_2 """

def construct_cone_considering_portmap(ver_file_name, modName, root_sig, cone, prev_conn):
    """
    Args: 
        ver_file_name: Name of the Verilog file
        root_sig: Signal which is to be kept as the root of the cone
        cone: The cone which is passed as input and to be returned as output
        prev_conn: Previous module.signal connection (This is to be connected to the new nodes)
        """
    #------------------------------------------------------------------
    # Find out the cdfg corresponding to the Verilog file (ver_file_name) and
    # the module (modName).
    #------------------------------------------------------------------
    # Using dictionary of dictionaries to store the number and module names
    if(DBG): print "-----------------------------------------------------------"
    print "construct_cone_considering_portmap: "
    if(DBG): print "main: ver_file_name: ", ver_file_name
    if(DBG): print "main: modName: ", modName 
    if(DBG): print "main: root_sig: ", root_sig
    if(DBG): print "main: prev_conn: ", prev_conn
    if(DBG): print "-----------------------------------------------------------"
    line1 = 'moduleNames_' + ver_file_name.split('.')[0] + '.txt'
    if(DBG): print line1
    dict_name = line1.split('moduleNames_')[1].split('.')[0]
    new_in_ports = []
    leaves = []
    l_sig_and_mapping = []
    with open(modNamesDir + line1.strip('\n'), "r") as f2:
        if(DBG): print "modNamesDir + line1.strip(\ n)", modNamesDir + line1.strip('\n')
        found_pat = 0
        for line2 in f2:
            # TODO Change the number from '2' to something else as per -
            # the number of spaces before the number in the 'index' column
            # in the file moduleNames_<>.txt
            pat = re.compile(r'\s{2,}\d+\s\w+')
            l_dict = re.findall (pat, line2) 
            if l_dict:
                found_pat = 1
                if l_dict[0].split()[1] == modName:
                    cdfgName = 'cdfg_' + dict_name + '_' + l_dict[0].split()[0] + '.txt'
        if found_pat == 0: # Cases where there is only one top module. You won't find a pattern \
                # "<module_number>  <module_name> there.
            if(DBG): print "<module_number>  <module_name> pattern not found"
            cdfgName = 'cdfg_' + dict_name + '.txt'
    if(DBG): print "cdfgName: ", cdfgName
    if(DBG): print "prev_conn (2) ", prev_conn

    delFile(parser_output_list)
    #------------------------------------------------------------------
    # Check if 'root_sig' is the output of any instantiated module.
    # Find the name of the module which is port-mapped in the Verilog file (ver_file_name)\
            # and which has the signal 'root_sig' as an output.
    # invoke call_visitor only if the signal root_sig is not the output of any port-mappings
    # Flag: Shows whether the signal is an output of any portmapping.
    mapped_signal = 0
    # Fresh signals (which can be primary inputs of ver_file_name or outputs of portmapped modules.
    fresh_signal = 0
    new_sigs_in_cone = []
    if find_mapped_module(ver_file_name, root_sig) != None:
        mapped_signal = 1 
        if(DBG): print "prev_conn (7) ", prev_conn
        if(DBG): print "No need to call call_visitor"
        mapped_sig_mod_list = find_mapped_module(ver_file_name, root_sig)
        if(DBG):print "1. mapped_sig_mod_list: ", mapped_sig_mod_list
        # Iterate over each mapped signal-module pair.
        for sig_mod_pair in mapped_sig_mod_list: 
            mapped_module, out_sig = sig_mod_pair[0], sig_mod_pair[1] 
            if(DBG): print "1. root_sig: ", root_sig 
            if(DBG): print "mapped_module: ", mapped_module 
            # Adding a new edge to the SDG for each connection in the port-mapping.
            if(DBG): print "New edge to the SDG port-mapping (1): (", mapped_module+"."+out_sig+','+mapped_module+"."+root_sig+")"
            cone.add_edge(mapped_module+"."+out_sig, mapped_module+"."+root_sig) 
            if prev_conn != None: 
                if(DBG): print "New edge with connection to previous node (3): (", mapped_module+"."+root_sig+","+prev_conn+")"
                cone.add_edge(mapped_module+"."+root_sig, prev_conn)
            #if(DBG)print "cone.nodes(1): ", cone.nodes()
            #if(DBG)print "cone.edges(1): ", cone.edges()
            # Find the Verilog file where the module 'mapped_module' is declared
            veri_file_with_decl = ver_file_with_decl(mapped_module)
            if(DBG): print "veri_file_with_decl: ", veri_file_with_decl 
            # Add the signals in the Verilog file ver_file_name which are mapped to the\
                    # outputs of the mapped_module to leaves. Also create of tuples containing actual signal\
                    # in the module and the corresponding mapped signal.
            if(DBG): print "2. root_sig: ", root_sig 
            if(DBG): print "mapped_module: ", mapped_module 
            if(DBG): print "out_sig: ", out_sig
            if(DBG): print "1. find_signal_mapped_to()"
            sig_mapped_to = find_signal_mapped_to(ver_file_name, mapped_module, out_sig)
            if(DBG):print "1. sig_mapped_to: ", sig_mapped_to 
            if sig_mapped_to:
                for new_sig in sig_mapped_to:
                    if(DBG): print "1. new_sig: ", new_sig
                    if(DBG): print "root_sig: ", root_sig
                    # If the signal sig_mapped_to contains more than one signals which are mapped to\
                            # out_sig, add only the signal which contains root_sig \
                            # (Eg: root_sig: 'a', new_sig: 'a[3:0]' should be added to\
                            # leaves. Else it leads to infinite loops. 
                    #------------------------------------------------------------
                    # Signal modification 1 
                    #------------------------------------------------------------
                    mod_new_sig_1 = new_sig.replace('-', '@')
                    rep = {"[": "\[", "]": "\]", "-": "@"}
                    rep = dict((re.escape(k), v) for k, v in rep.iteritems())
                    pattern = re.compile("|".join(rep.keys()))
                    mod_root_sig_1 = pattern.sub(lambda m: rep[re.escape(m.group(0))], root_sig)
                    #------------------------------------------------------------
                    # Signal modification 2 
                    #------------------------------------------------------------
                    mod_root_sig_2 = root_sig.replace('-', '@')
                    rep = {"[": "\[", "]": "\]", "-": "@"}
                    rep = dict((re.escape(k), v) for k, v in rep.iteritems())
                    pattern = re.compile("|".join(rep.keys()))
                    mod_new_sig_2 = pattern.sub(lambda m: rep[re.escape(m.group(0))], new_sig)
                    #------------------------------------------------------------
                    # Signal modification 3 
                    #------------------------------------------------------------
                    mod_root_sig_3, is_root_sig_modified = extr_single_sig_name(root_sig)
                    mod_new_sig_3, is_new_sig_modified = extr_single_sig_name(new_sig)
                    #------------------------------------------------------------
                    # Case where root_sig is contained in new_sig
                    if re.search(mod_root_sig_1, mod_new_sig_1):
                        if(DBG): print "With modification 1"
                        if(DBG): print "root_sig: ", root_sig, " matches new_sig: ", new_sig
                        leaves.append(new_sig)
                        if(DBG): print "New port mapped signal added to leaves (1): ", new_sig
                        l_sig_and_mapping.append((out_sig, new_sig, mapped_module, veri_file_with_decl))
                    # Case where new_sig is contained in root_sig
                    elif re.search(mod_new_sig_2, mod_root_sig_2):
                        if(DBG): print "With modification 2"
                        if(DBG): print "new_sig: ", new_sig, " matches root_sig: ", root_sig
                        leaves.append(new_sig)
                        if(DBG): print "New port mapped signal added to leaves (1): ", new_sig
                        l_sig_and_mapping.append((out_sig, new_sig, mapped_module, veri_file_with_decl))
                    # Case where just the signal names of new_sig and root_sig matches. 
                    elif re.search(mod_new_sig_3, mod_root_sig_3):
                        if(DBG): print "With modification 3"
                        if(DBG): print "new_sig: ", new_sig, " matches root_sig: ", root_sig
                        leaves.append(new_sig)
                        if(DBG): print "New port mapped signal added to leaves (1): ", new_sig
                        l_sig_and_mapping.append((out_sig, new_sig, mapped_module, veri_file_with_decl))
                    else:
                        if(DBG): print "root_sig: ", root_sig, " doesn't match new_sig: ", new_sig
                if(DBG): print "2. l_sig_and_mapping: ", l_sig_and_mapping
            else:
                if(DBG): print "No signal mapped to out_sig: ",out_sig,", in mapped_module: ",mapped_module,", ver_file_name: ",ver_file_name
            if(DBG): print "8. leaves: ", leaves
        if(DBG): print "leaves (1): ", leaves
        if(DBG): print "1. dict_sdg_edges: ", dict_sdg_edges
    else:
        fresh_signal = 1
        if(DBG): print "prev_conn (8) ", prev_conn
        if(DBG): print "Invoking call_visitor"
        call_visitor(cdfgProcessed + cdfgName)
        file_par_out = open(parser_output_list, 'r')
        delFile(input_list)
        with open(parser_output_list, 'r') as f_r, open(input_list, 'a+') as f_w:
            for line in f_r:
                f_w.write(line)
        if(DBG): print "new_sigs_in_cone (1): ", new_sigs_in_cone
        if(DBG): print "construct_cone_ignoring_portmap: ", "root_sig: ", root_sig,\
                "modName: ", modName
        cone, new_sigs_in_cone = construct_cone_ignoring_portmap (input_list, root_sig, cone, modName)
        if(DBG): print "new_sigs_in_cone (2): ", new_sigs_in_cone
        for sig in new_sigs_in_cone:
            leaves.append(sig)
            if(DBG): print "New signal added to leaves (2): ", sig
            if(DBG): print "leaves (5): ", leaves
        #if(DBG)print "cone.nodes(2): ", cone.nodes()
        #if(DBG)print "cone.edges(2): ", cone.edges()
    if(DBG): print "prev_conn (3) ", prev_conn
    new_in_ports_tmp = []
    new_sig_list = []
    repeted_node_of_cone = 0 
    list_index = 0
    # Note: All the signals in leaves are local signals declared in ver_file_name\
            # and NOT the signals used in the definition of the modules which are\
            # port-mapped in Verilog file ver_file_name.
    for sig in leaves:
        if sig != None: #TODO Remove this redundant check for None by making sure that None doesn't fill up leaves.
            if(DBG): print "sig (1): ", sig
            only_sig_name, mapped_part_of_in_sig = extr_single_sig_name(sig)
            port_type = find_port_type(modName, only_sig_name)
            # Check if the signal 'sig' is an input of the module 'modName'.
            if port_type != 'in':
                if(DBG): print "sig (2): ", sig
                # Append the new signals which are not to leaves. 
                # TODO Check dict_sdg_edges for repetition before calling find_signal_mapped_to.
                # List of the signals in the file ver_file_name, which are mapped to the input ports of\
                        # the module modName which are in the cone.
                if mapped_signal:
                    if(DBG): print "mapped_signal = 1 for :", sig
                    # Find out the original signal in the module.
                    if(DBG): print "1. l_sig_and_mapping: ", l_sig_and_mapping
                    if(DBG): print "sig (4): ", sig
                    for item in l_sig_and_mapping:
                        if(DBG): print "item: ", item
                        if item[1] == sig:
                            original_sig = item[0]
                            #raw_input("Press Enter to continue...")
                            break # To avoid exit condition when l_sig_and_mapping has more than one entry\
                                    # and there is no match with the first entry.
                        else:
                            pass
                            #sys.exit("Exit: Can't locate the original signal in a port-map")
                    if(DBG): print "4. dict_sdg_edges: ", dict_sdg_edges
                    # Check whether this part of the cone is already found (earlier).
                    for item in dict_sdg_edges[ver_file_name]:
                        if item == original_sig:
                            repeted_node_of_cone = 1
                    if repeted_node_of_cone == 0:
                        if(DBG): print "1. new entry to dict_sdg_edges (mapped_sig): ", sig
                        dict_sdg_edges[ver_file_name].append(sig)
                        # l_sig_and_mapping=[(orig_signal_in_module, signal_mapped_to, mapped_module, veri_file_with_decl), ...]
                        if(DBG): print "------------START: l_sig_and_mapping---------------"
                        for item in l_sig_and_mapping:
                            if(DBG): print "prev_conn (passed): ", modName+"."+sig
                            for new_sig_tmp in construct_cone_considering_portmap(item[3], item[2], original_sig, \
                                    cone, item[2]+"."+sig):
                                if(DBG): print "new_sig_tmp: ", new_sig_tmp
                                # Connecting the inputs returned by construct_cone_considering_portmap function to the \
                                        # signal to which it is mapped in the main file.
                                #------------------------------------------------
                                if(DBG): print "2. find_signal_mapped_to("+ver_file_name+", "+item[2]+", "+new_sig_tmp+")" 
                                mapped_sig_list = find_signal_mapped_to(ver_file_name, item[2], new_sig_tmp)
                                if (DBG): print "1. mapped_sig_list: ", mapped_sig_list
                                for new_sig in mapped_sig_list:
                                    if(DBG): print "2. new_sig: ",new_sig 
                                    if(DBG): print "New edge to the SDG (1): (", modName+"."+new_sig+','+item[2]+"."+new_sig_tmp+")"
                                    cone.add_edge(modName+"."+new_sig, item[2]+"."+new_sig_tmp) 
                                    #TODO Use instance name instead of the actual module name (modName). 
                                    #if(DBG): print "new entry to dict_sdg_edges: ", sig
                                    #dict_sdg_edges[ver_file_name].append(sig)
                                    #------------------------------------------------
                                    new_sig_list.append(new_sig)
                                    if(DBG): print "1. new_sig_list: ", new_sig_list 
                        if(DBG): print "------------END: l_sig_and_mapping---------------"
                    else: 
                        if(DBG): print "Deleting the mapped_signal: ", leaves[list_index], " to avoid infinite loop in SDG generation"
                        del leaves[list_index]
                        repeted_node_of_cone = 0
                if fresh_signal:
                    if(DBG): print "fresh_signal = 1 for :", sig
                    # Check whether this part of the cone is already found (earlier).
                    if(DBG): print "2. dict_sdg_edges: ", dict_sdg_edges
                    for item in dict_sdg_edges[ver_file_name]:
                        if item == sig:
                            if(DBG): print "Node repetition found for the signal: ", item
                            repeted_node_of_cone = 1
                    if repeted_node_of_cone == 0:
                        if(DBG): print "2. new entry to dict_sdg_edges (fresh_sig): ", sig
                        dict_sdg_edges[ver_file_name].append(sig)
                        for new_sig_tmp in construct_cone_considering_portmap(ver_file_name, modName, sig, cone, modName+"."+sig):
                            if(DBG): print "4. find_signal_mapped_to()"
                            if find_signal_mapped_to(ver_file_name, modName, new_sig_tmp):
                                if(DBG): print "5. find_signal_mapped_to()"
                                for new_sig in find_signal_mapped_to(ver_file_name, modName, new_sig_tmp):
                                    new_sig_list.append(new_sig)
                            else:
                                new_sig_list.append(new_sig_tmp)
                    else:
                        if(DBG): print "Deleting the fresh_signal: ", leaves[list_index], " to avoid infinite loop in SDG generation"
                        del leaves[list_index]
                        repeted_node_of_cone = 0
                if(DBG): print "leaves (7): ", leaves
                if(DBG): print "2. new_sig_list: ", new_sig_list 
                if new_sig_list:
                    add_only_new_items(leaves, new_sig_list)
                    if(DBG): print "leaves (9): ", leaves
                    """for new_sig in new_sig_list:
                        if new_sig != None: #TODO This is redundant, check if new_sig_list is empty(properly) instead.
                            if(DBG): print "sig: ", sig
                            if(DBG): print "New edge to the SDG (1): (", modName+"."+new_sig+','+modName+"."+sig+")"
                            cone.add_edge(modName+"."+new_sig, modName+"."+sig) #TODO Use instance name instead of the actual module name (modName). 
                            dict_sdg_edges[ver_file_name].append(sig)
                            if(DBG): print "3. dict_sdg_edges: ", dict_sdg_edges"""
                else:
                    if(DBG): print "Info: new_sig_list is empty. Probably because of the deletion of a repeted node which would have led to infinite loop in SDG generation"
                if(DBG): print "leaves (4): ", leaves
            # If the signals in leaves are 'in' ports, append it to new_in_ports.
            else:
                if (mapped_part_of_in_sig):
                    new_in_ports_tmp.append(only_sig_name)
                    if(DBG): print "Adding extra edge since mappd_part_of_in_sig = 1"
                    if(DBG): print "Edge: ",modName+"."+only_sig_name, modName+"."+sig
                    cone.add_edge(modName+"."+only_sig_name, modName+"."+sig)
                else:
                    new_in_ports_tmp.append(sig)
                    if(DBG): print "sig (3): ", sig
            list_index += 1
        # Changing flags to make sure that the second iteration onwards, signals will be considered fresh. 
        mapped_signal = 0
        fresh_signal = 1
    #-----------------
    add_only_new_items(new_in_ports, new_in_ports_tmp)
    if(DBG): print "leaves (6): ", leaves
    if(DBG): print "new_in_ports: ", new_in_ports
    return new_in_ports
    #------------------------------------------------------------------
    
def ver_file_with_decl(mapped_module):
    """ Find the Verilog file where the module 'mapped_module' is declared."""
    #if(DBG): print "ver_file_with_decl for :", mapped_module
    for item in l_moduleInfo:
        if item[1] == mapped_module:
            if(DBG): print "The module " + mapped_module + " is declared in " + item[0]
            return item[0]

def find_signal_mapped_to(ver_file_name, mod_name, orig_sig_name):
    """ Finds the signal which is mapped to a particular signal in an instantiated module
    Args:
        ver_file_name: Name of the verilog file where the relevant port-mapping is present.
        mod_name: Name of the module  (Not the name of instance) which is instantiated in the file\
                ver_file_name.
        orig_sig_name: Name of the signal in the module (Not the signal to which is it mapped).
    Returns:
        List of signals in the the file ver_file_name to which the signal orig_sig_name in the module\
                mod_name is mapped. Note: In port-mapping a signal can be mapped to a combination of\
                multiple signals or parts of it. Hence returning a list instead of a single signal.
    """
    if(DBG): print "find_signal_mapped_to for the signal: "+orig_sig_name+", module: "+mod_name,\
            ", ver_file_name: ", ver_file_name
    mapped_string = ""
    mapped_sigs = []
    map_found = 0
    for item in l_portMap:
        if item[0] == ver_file_name and item[1] == mod_name:
            #if(DBG): print "ver_file_name: ", item[0]
            #if(DBG): print "mod_name: ", item[1]
            for i in range(len(item)/3):
                # Ignoring the first three entries of l_portMap as they don't contain any signals.
                if i>0:
                    #if(DBG): print "item[(i+1)*3-2] ", item[(i+1)*3-2]
                    #if(DBG): print "item[(i+1)*3-1] ", item[(i+1)*3-1]
                    if item[(i+1)*3-2] == orig_sig_name:
                        if(DBG): print "The signal " + orig_sig_name + " is mapped to: " + item[(i+1)*3-1]
                        mapped_string = item[(i+1)*3-1]
                        map_found = 1
    #If there is a port-mapping then parse the mapped signal and return a list.
    if map_found:
        pat1 = re.compile(r'\{(.*)\}')
        match1 = re.match (pat1, mapped_string)
        if match1:
            if(DBG): print match1.groups()
            if match1.groups():
                pat1_1 = "(\w+)\[.*?\]"
                pat1_2 = "(\w+),?" 
                if re.findall(pat1_1, match1.groups()[0]):
                    mapped_sigs= re.findall(pat1_1, match1.groups()[0])
                    if(DBG): print ("mapped_sigs(pat1_1): ", mapped_sigs)
                    return mapped_sigs
                elif re.findall(pat1_2, match1.groups()[0]):
                    mapped_sigs= re.findall(pat1_2, match1.groups()[0])
                    if(DBG): print ("mapped_sigs(pat1_2?): ", mapped_sigs)
                    return mapped_sigs
        else:
            # If there is only one signal in the mapped_string, return it as a single element list.
            mapped_sigs.append(mapped_string)
            if(DBG): print ("mapped_sigs(single_sig): ", mapped_sigs)
            return mapped_sigs
    else:
        if(DBG): print "The signal " + orig_sig_name + " is NOT mapped to anything."


def find_port_type(mod_name, sig_name):
    """ Finds whether the signal 'sig' is an 'in' or 'out' port in the module 'mod_name'
    Args:
        mod_name: Name of the module
        sig: Name of the signal
    Returns:
        'in' or 'out'
        """
    if(DBG): print "find_port_type for the signal: "+sig_name+", module: "+mod_name
    for item in l_moduleInfo:
        if item[1] == mod_name:
            for i in range(len(item)/2):
                # Ignoring the first two entries of l_portMap as they don't contain any signals.
                if i>0:
                    if (item[(i+1)*2-1] == sig_name):
                        #if(DBG): print "The signal " + sig_name + " is of type " + item[(i+1)*2-2]
                        return item[(i+1)*2-2]

def find_mapped_module(ver_file_name, sig_name):
    """ Find the name of the module which is port-mapped in the Verilog file\
            ver_file_name and which has an output signal mapped to the signal\
            sig_name
    Returns: 
        A list of tuples with each tuple containing
            1. Name of the module (not the instance name).
            2. Signal in the module to which the signal 'sig_name' is port-mapped.
        """
    if(DBG): print "find_mapped_module for " + sig_name
    mod_sig_list = []
    l_sig = []
    #------------------------------------------------------------
    # Replacement of special characters in sig_nam eto avoid regex errors
    #------------------------------------------------------------
    #rep = {"[": "\[", "]": "\]", "-": "@"}
    #rep = dict((re.escape(k), v) for k, v in rep.iteritems())
    #pattern = re.compile("|".join(rep.keys()))
    #mod_sig_name = pattern.sub(lambda m: rep[re.escape(m.group(0))], sig_name)
    mod_sig_name = sig_name
    #if(DBG): print "mod_sig_name ", mod_sig_name
    #------------------------------------------------------------
    #--------------------------------------------------------
    # Generate lists from mod_sig_name with only signal names (not the bit-ranges)
    #--------------------------------------------------------
    sig_names = []
    pat1 = re.compile(r'\{(.*)\}')
    match1_sig = re.match (pat1, mod_sig_name)
    pat2 = re.compile('(\w+)\[.*\]')
    match2_sig = re.match (pat2, mod_sig_name)
    if match1_sig:
        if(DBG): print match1_sig.groups()
        if match1_sig.groups():
            # FUTURE IMPROVEMENT: The logic under this line will have to be changes in there is a port-mapping\
                    # with a combination of signals with and withoug bit-ranges specified (Eg: .a({b,c[3:0]}) will \
                    # find only c as per the current logic and will miss b. Same applies to l_item as well.
            # Case1: Eg: "sig1[3:0], sig2[5:0]"
            sig_names_1=re.findall("(\w+)\[.*?\]", match1_sig.groups()[0])
            # Case1: Eg: "sig1, sig2"
            # FUTURE IMPROVEMENT: Use this regex option (which is more precisely for comma separated signals): "(,?[a-zA-Z0-9_]*,?)"
            sig_names_2=re.findall("(\w+)", match1_sig.groups()[0]) 
            if sig_names_1:
                if(DBG): print ("sig_names_1(pat1_1): ", sig_names_1)
                l_sig+=sig_names_1
            elif sig_names_2:
                if(DBG): print ("sig_names_2(pat1_2): ", sig_names_2)
                l_sig+=sig_names_2
    elif match2_sig:
        if(DBG): print match2_sig.groups()
        if match2_sig.groups():
            sig_names=re.findall("(\w+)\[.*?\]", mod_sig_name)
            if(DBG): print ("sig_names(pat2): ", sig_names)
            l_sig+=sig_names
    else:
        # If there is only one clean signal in the mod_sig_name which doesn't match above patterns.
        if(DBG): print ("mod_sig_name (single_sig): ", mod_sig_name)
        l_sig.append(mod_sig_name)
    #--------------------------------------------------------
    for item in l_portMap:
        if item[0] == ver_file_name:
            #if(DBG): print "ver_file_name: ", ver_file_name
            #if(DBG): print "item: ", item
            for i in range(len(item)/3):
                # Ignoring the first three entries of l_portMap as they don't contain any signals.
                if i>0:
                    if (item[(i+1)*3-3] == 'out'):
                        l_item = []
                        #if(DBG): print "item[(i+1)*3-3] ", item[(i+1)*3-3]
                        #if(DBG): print "item[(i+1)*3-1] ", item[(i+1)*3-1]
                        #if(DBG): print "sig_name ", sig_name
                        #------------------------------------------------------------
                        # Replacement of special characters to avoid regex errors
                        #------------------------------------------------------------
                        #mod_item = item[(i+1)*3-1].replace('-', '@')
                        mod_item = item[(i+1)*3-1]
                        #if(DBG): print "mod_item ", mod_item
                        #------------------------------------------------------------
                        #------------------------------------------------------------
                        # Generate lists from mod_item with only signal names (not the bit-ranges)
                        #------------------------------------------------------------
                        pat1 = re.compile(r'\{(.*)\}')
                        match1_sig = re.match (pat1, mod_item)
                        pat2 = re.compile('(\w+)\[.*\]')
                        match2_sig = re.match (pat2, mod_item)
                        if match1_sig:
                            if(DBG): print match1_sig.groups()
                            if match1_sig.groups():
                                sigs_in_item_1=re.findall("(\w+)\[.*?\]", match1_sig.groups()[0])
                                sigs_in_item_2=re.findall("(\w+)", match1_sig.groups()[0])
                                if sigs_in_item_1:
                                    if(DBG): print ("sigs_in_item_1(pat1_1): ", sigs_in_item_1)
                                    l_item+=sigs_in_item_1
                                elif sigs_in_item_2:
                                    if(DBG): print ("sigs_in_item_2(pat1_2): ", sigs_in_item_2)
                                    l_item+=sigs_in_item_2
                        elif match2_sig:
                            if(DBG): print match2_sig.groups()
                            if match2_sig.groups():
                                sigs_in_item=re.findall("(\w+)\[.*?\]", mod_item)
                                if(DBG): print ("sigs_in_item(pat2): ", sigs_in_item)
                                l_item+=sigs_in_item
                        else:
                            # If there is only one clean signal in the mod_item which doesn't match above patterns.
                            if(DBG): print ("mod_item (single_sig): ", mod_item)
                            l_item.append(mod_item)
                        #------------------------------------------------------------
                        if(DBG): print "l_sig: ", l_sig
                        if(DBG): print "l_item: ", l_item
                        for sig_part in l_sig:
                            for item_part in l_item:
                                if sig_part == item_part:
                                    if(DBG): print "Signal match for port map found for, mod_sig_name: "+mod_sig_name+" mod_item: "+mod_item
                                    if(DBG): print "SignalMap: The signal ", sig_name, "is connected to the output signal: ", item[(i+1)*3-2]+\
                                            " of the module: " + item[1]
                                    # Return the module name and the name of the \
                                            #signal in the module to which the signal 'sig_name' is port-mapped.
                                    mod_sig_list.append((item[1], item[(i+1)*3-2]))
                        del l_item[:]
                        del sigs_in_item[:]
    if mod_sig_list:
        if(DBG): print "mod_sig_list: ", mod_sig_list
        return mod_sig_list
    else:
        if(DBG): print "No mapped module found for the signal: ", sig_name

def construct_cone_ignoring_portmap(input_list, root_sig, cone, mod_name):
    """ Construct cone ignoring portmappings
    Args:
        input_list: The output of CDFG parser
        root_sig: Signal based on which the cone is to be created
        cone: The cone which is passed as input and also returned as output
        mod_name: The module where the signal 'root_sig' is located
    Returns:
        cone: The updated cone.
        new_leaf_sigs_in_cone: Signals newly added to the cone and are the leaves of the cone
        """
    # Construct cone from the list of signals and necessry flags (embedded in the list)
    if(DBG): print "---construct_cone_ignoring_portmap"
    l_nb_assign = []
    l_index_nb_assign = []
    new_leaf_sigs_in_cone = []
    # Get the signals and their range of influence (in terms of start and end index).
    l_infl = find_influencer_sigs(input_list)
    #if(DBG): print "l_infl: ", l_infl
    #if(DBG): print "len(l_infl): ", len(l_infl)
    l_root_sig_indices = find_root_sig_index(root_sig, input_list)
    #if(DBG): print "l_root_sig_indices: ", l_root_sig_indices 
    # Also removes duplicate signals (Note: Order is not retained).
    l_tmp, cone = construct_line_of_cone(l_infl, l_root_sig_indices, cone, mod_name)
    new_sigs_in_cone = list(set(l_tmp))
    if(DBG): print "1. new_sigs_in_cone: ", new_sigs_in_cone  
    #--------------------------------------------------------------------------
    # Create the cone using construct_line_of_cone function.
    #--------------------------------------------------------------------------
    for item in new_sigs_in_cone:
        #if(DBG): print "\n------------------------------------------------------------\n"
        #if(DBG): print "Finding line for: ", item
        #if(DBG): print "\n------------------------------------------------------------\n"
        l_root_sig_indices_for_item = find_root_sig_index(item, input_list)
        # Get new signal in the cone corresponding to the signal 'item'
        # TODO Remove duplicates using set in list. Use function.
        sigs_in_cone_for_item, cone = construct_line_of_cone(l_infl, l_root_sig_indices_for_item, cone, mod_name) 
        #if(DBG): print "7. sigs_in_cone_for_item: ", sigs_in_cone_for_item   
        # Append the sigals in the new cone to the master list of 'signals in the cone'.
        add_only_new_items(new_sigs_in_cone, sigs_in_cone_for_item)
        #if(DBG): print "2. new_sigs_in_cone: ", new_sigs_in_cone 
        #if(DBG): print "\n------------------------------------------------------------\n"
    if(DBG): print "cone.nodes(3): ", cone.nodes()
    if(DBG): print "cone.edges(3): ", cone.edges()
    if(DBG): print "2. new_sigs_in_cone: ", new_sigs_in_cone  
    leaf_sigs_in_cone_all = ([x.split(".")[len(x.split("."))-1] for x in cone.nodes() if cone.in_degree(x)==0])
    if(DBG): print "leaf_sigs_in_cone_all: ", leaf_sigs_in_cone_all
    for sig in leaf_sigs_in_cone_all:
        if sig in new_sigs_in_cone:
            new_leaf_sigs_in_cone.append(sig)
    if(DBG): print "1. new_leaf_sigs_in_cone: ", new_leaf_sigs_in_cone
    return cone, new_leaf_sigs_in_cone

def add_only_new_items(l_org, l_new):
    """ Find out the elements in l_new which are not there in l_org and append it with l_org.
    Args: 
        l_org: Original list.
        l_new: new list.
    Returns:
        The modified list.
    Raises: No error
    """
    #if(DBG): print "l_new: ", l_new
    #if(DBG): print "l_org: ", l_org
    l_org += list(set(l_new) - set(l_org))

def construct_line_of_cone(l_infl, l_root_sig_indices, cone, mod_name):
    """ Add a line of the cone to the graph 'cone'
    Args:
        l_infl: Signals which influences the root signal
        l_root_sig_indices: List with the root signal and the index ranges 
            where it is found.
    Returns:
        List of signals which are in the line_of_cone
        It also updates the graph 'cone' with these signals
    Raises:
        No error
    """
    sigs_in_line_of_cone = []
    #--------------------------------------------------------------------------
    # Find the overlapping indices
    #--------------------------------------------------------------------------
    l_infl_onlyIndices = []
    l_root_sig_indices_onlyIndices = []
    for i in range(len(l_infl)):
        l_infl_onlyIndices.append(l_infl[i][1])
    for i in range(len(l_root_sig_indices)):
        l_root_sig_indices_onlyIndices.append(l_root_sig_indices[i][1])
    l_overlap = get_overlapping_indices(l_infl_onlyIndices, l_root_sig_indices_onlyIndices)
    #if(DBG): print "l_overlap: ", l_overlap
    #--------------------------------------------------------------------------

    #--------------------------------------------------------------------------
    # Add edges to the line_of_cone based on the overlap.
    #--------------------------------------------------------------------------
    #if(DBG): print "\nl_infl_onlyIndices: ",l_infl_onlyIndices
    #if(DBG): print "\nl_root_sig_indices_onlyIndices: ", l_root_sig_indices_onlyIndices
    #if(DBG): print "\nl_infl: ",l_infl
    #if(DBG): print "\nl_root_sig_indices: ", l_root_sig_indices
    for i in range(len(l_overlap)):
        #if(DBG): print "i: ", i
        #if(DBG): print "\nl_root_sig_indices[l_overlap[i][0]][0]: ", l_root_sig_indices[l_overlap[i][0]][0]
        #if(DBG): print "l_root_sig_indices[l_overlap[i][0]][1]: ", l_root_sig_indices[l_overlap[i][0]][1]
        #if(DBG): print "l_infl[l_overlap[i][1]][0]: ", l_infl[l_overlap[i][1]][0]
        #if(DBG): print "l_infl[l_overlap[i][1]][1]: ", l_infl[l_overlap[i][1]][1]
        #if(DBG): print "New edge added to the line of cone: ", mod_name+"."+l_infl[l_overlap[i][1]][0] + "," + mod_name+"."+l_root_sig_indices[l_overlap[i][0]][0]
        cone.add_edge(mod_name+"."+l_infl[l_overlap[i][1]][0], mod_name+"."+l_root_sig_indices[l_overlap[i][0]][0])
        sigs_in_line_of_cone.append(l_infl[l_overlap[i][1]][0])
    return sigs_in_line_of_cone, cone
    #--------------------------------------------------------------------------

def find_root_sig_index(root_sig, input_list):
    """ Find out the index or indices (Eg: in 'case' blocks) of the root signal.
    Args: 
        root_sig: Name of the signal whose index needs to be found.
        input_list: The list with signals, labels etc.
    Returns:
        List of tuples in the following format
        [(<sig_name>, (<start_index>, <end_index>)), ...]
            <start_index>: Position of [LSIDE:]
            <end_index>: Position of [:LSIDE]
    Raises:
        No error
    """
    l_o = []
    # Get all signals in between [LSIDE:] and [:LSIDE]
    l_lside, l_index_lside = extr_lside_blocks(input_list)
    #if(DBG): print "l_lside: ", l_lside
    #if(DBG): print "l_index_lside: ", l_index_lside
    # Find out the location of root_sig in l_lside and add that signal along with -
    # it's index to the output list.
    i = 0
    for item in l_lside:
        if item == root_sig:
            #if(DBG): print "root_sig: ", root_sig + " found"
            l_o.append((item,l_index_lside[i]))
        i += 1
    return l_o

def extr_lside_blocks(input_list):
    """Extract the blocks between [LSIDE:] and [:LSIDE]
    Args:
        input_list: The output obtained by parsing quteRTL output using Antlr
    Returns: 
        List of sections between [LSIDE:] and [:LSIDE]
        List of touple containg of starting and ending indices of the blocks
    Raises: No exception
    """
    #if(DBG): print "---extr_lside_blocks "
    l_text = []
    l_index = []
    with open(input_list, "r") as f:
        for line in f:
            #if(DBG): print line
            l_s = ([m.start() for m in re.finditer('\[LSIDE:\]', line)])
            l_e = ([m.start() for m in re.finditer('\[:LSIDE\]', line)])
    #if(DBG): print "l_s: ", l_s
    #if(DBG): print "l_e: ", l_e
    with open(input_list, "r") as f:
        for line in f:
            #if(DBG): print line
            for i in range(len(l_s)):
                #if(DBG): print "i_start: ", l_s[i]+12 
                #if(DBG): print "i_end: ", l_e[i]
                l_text.append (line[l_s[i]+8 : l_e[i]])
                l_index.append((l_s[i]+8, l_e[i])) #TODO Check if the index is 8?
    l_text_o = remove_labels(l_text)
    return l_text_o, l_index


def find_influencer_sigs(input_list):
    """Find the signals and the range of indices where they influence other signals
    Args:
        input_list: File with lists containing start and end labels for various blocks
        (Eg: if_block).
    Returns:
        A list of tuples with each tuple in the following format
            (<signal_name>, (<start_index>, <end_index>)
    Raises: No error
    """
    #if(DBG): print "---find_influencer_sigs"

    l_infl = []

    l_if_block, l_index_if_block = extr_if_blocks(input_list)
    #if(DBG): print 'l_if_block: ', l_if_block
    #if(DBG): print 'l_index_if_block: ', l_index_if_block
    append_to_list_of_tuples(l_if_block, l_index_if_block, l_infl)

    l_case_block, l_index_case_block = extr_case_blocks(input_list)
    #if(DBG): print 'l_case_block: ', l_case_block
    #if(DBG): print 'l_index_case_block: ', l_index_case_block
    append_to_list_of_tuples(l_case_block, l_index_case_block, l_infl)

    l_always_block, l_index_always_block = extr_always_blocks(input_list)
    #if(DBG): print 'l_always_block: ', l_always_block
    #if(DBG): print 'l_index_always_block: ', l_index_always_block
    append_to_list_of_tuples(l_always_block, l_index_always_block, l_infl)

    l_for_block, l_index_for_block = extr_for_blocks(input_list)
    #if(DBG): print 'l_for_block: ', l_for_block
    #if(DBG): print 'l_index_for_block: ', l_index_for_block
    append_to_list_of_tuples(l_for_block, l_index_for_block, l_infl)

    l_nb_assign, l_index_nb_assign = extr_nb_assigns(input_list)
    #if(DBG): print 'l_nb_assign: ', l_nb_assign
    #if(DBG): print 'l_index_nb_assign: ', l_index_nb_assign
    #if(DBG): print 'len(l_nb_assign): ', len(l_nb_assign)
    #if(DBG): print 'len(l_index_nb_assign): ', len(l_index_nb_assign)
    append_to_list_of_tuples(l_nb_assign, l_index_nb_assign, l_infl)

    l_condop_block, l_index_condop_block = extr_condop_blocks(input_list)
    #if(DBG): print 'l_condop_block: ', l_condop_block
    #if(DBG): print 'l_index_condop_block: ', l_index_condop_block
    append_to_list_of_tuples(l_condop_block, l_index_condop_block, l_infl)

    return l_infl

def append_to_list_of_tuples(l1, l2, l_out):
    """Take the elements of lists l1 and l2 one by one, convert them into
        tuples. Append those tuples to l_out. Consider only valid Verilog signal names.
    Args:
        l1: List 1
        l2: List 2
    Returns:
        l_out
    Raises: No error
    """
    valid_sigs_list = []
    for i in range(len(l1)):
        valid_sigs_list = extr_sigs(l1[i])
        for j in range(len(valid_sigs_list)):
            l_out.append((valid_sigs_list[j], l2[i]))
        valid_sigs_list = []
    return l_out

def extr_if_blocks(text):
    """Extract the blocks between [IF_COND:] and [:IF_COND]
    Args:
        text: The output obtained by parsing quteRTL output using Antlr
    Returns: 
        List of sections between [IF_COND:] and [:IF_COND]
        List of touple containg of starting and ending indices of [IF_BLOCK:] and [:IF_BLOCK] 
    Raises: No exception
    """
    #if(DBG): print "---extr_if_blocks"
    l_text = []
    l_index = []
    l_s_if_cond = []
    l_e_if_cond = []
    l_s_if_block = []
    l_e_if_block = []

    with open(input_list, "r") as f:
        for line in f:
            #if(DBG): print line
            l_s_if_cond = ([m.start() for m in re.finditer('\[IF_COND:\]', line)])
            l_e_if_cond = ([m.start() for m in re.finditer('\[:IF_COND\]', line)])
            l_s_if_block = ([m.start() for m in re.finditer('\[IF_BLOCK:\]', line)])
            l_e_if_block = ([m.start() for m in re.finditer('\[:IF_BLOCK\]', line)]) 
    #if(DBG): print "l_s_if_cond: ", l_s_if_cond
    #if(DBG): print "l_e_if_cond: ", l_e_if_cond
    #if(DBG): print "l_s_if_block: ", l_s_if_block
    #if(DBG): print "l_e_if_block: ", l_e_if_block
    with open(input_list, "r") as f:
        for line in f:
            #if(DBG): print line
            for i in range(len(l_s_if_cond)):
                l_text.append (line[l_s_if_cond[i]+10 : l_e_if_cond[i]])
                l_index.append((l_s_if_block[i]+12, l_e_if_block[i]))
    l_index_o, l_text_tmp = index_reorder (l_index, l_text) 
    #if(DBG): print "l_index_o_IF: ", l_index_o
    #if(DBG): print "l_text_tmp_IF: ", l_text_tmp
    l_text_o = remove_labels(l_text_tmp) 
    return l_text_o, l_index_o

def extr_condop_blocks(text):
    """Extract the blocks between [CONDOP_COND:] and [:CONDOP_COND]
    Args:
        text: The output obtained by parsing quteRTL output using Antlr
    Returns: 
        List of sections between [CONDOP_COND:] and [:CONDOP_COND]
        List of touple containg of starting and ending indices of [CONDOP_BLOCK:] and [:CONDOP_BLOCK] 
    Raises: No exception
    """
    #if(DBG): print "---extr_condop_blocks"
    l_text = []
    l_index = []

    with open(input_list, "r") as f:
        for line in f:
            #if(DBG): print line
            l_s_condop_cond = ([m.start() for m in re.finditer('\[CONDOP_COND:\]', line)])
            l_e_condop_cond = ([m.start() for m in re.finditer('\[:CONDOP_COND\]', line)])
            l_s_condop_block = ([m.start() for m in re.finditer('\[CONDOP_BLOCK:\]', line)])
            l_e_condop_block = ([m.start() for m in re.finditer('\[:CONDOP_BLOCK\]', line)]) 
    with open(input_list, "r") as f:
        for line in f:
            #if(DBG): print line
            for i in range(len(l_s_condop_cond)):
                l_text.append (line[l_s_condop_cond[i]+10 : l_e_condop_cond[i]])
                l_index.append((l_s_condop_block[i]+12, l_e_condop_block[i]))
    l_index_o, l_text_tmp = index_reorder (l_index, l_text) 
    l_text_o = remove_labels(l_text_tmp) 
    return l_text_o, l_index_o

def extr_case_blocks(text):
    """Extract the blocks between [CASE_BLOCK:] and [:CASE_BLOCK]
    Args:
        text: The output obtained by parsing quteRTL output using Antlr
    Returns: 
        List of sections between [CASE_COND:] and [:CASE_COND]
        List of touple containg of starting and ending indices of [CASE_BLOCK:] and [:CASE_BLOCK] 
    Raises: No exception
    """
    #if(DBG): print "---extr_case_blocks"
    l_text = []
    l_index = []

    with open(input_list, "r") as f:
        for line in f:
            #if(DBG): print line
            l_s_case_cond = ([m.start() for m in re.finditer('\[CASE_COND:\]', line)])
            l_e_case_cond = ([m.start() for m in re.finditer('\[:CASE_COND\]', line)])
            l_s_case_block = ([m.start() for m in re.finditer('\[CASE_BLOCK:\]', line)])
            l_e_case_block = ([m.start() for m in re.finditer('\[:CASE_BLOCK\]', line)]) 
    with open(input_list, "r") as f:
        for line in f:
            #if(DBG): print line
            for i in range(len(l_s_case_cond)):
                l_text.append (line[l_s_case_cond[i]+12 : l_e_case_cond[i]])
                l_index.append((l_s_case_block[i]+14, l_e_case_block[i]))
    l_index_o, l_text_tmp = index_reorder (l_index, l_text) 
    l_text_o = remove_labels(l_text_tmp) 
    return l_text_o, l_index_o

def extr_always_blocks(text):
    """Extract the blocks between [ALWAYS_BLOCK:] and [:ALWAYS_BLOCK]
    Args:
        text: The output obtained by parsing quteRTL output using Antlr
    Returns: 
        List of sections between [ALWAYS_COND:] and [:ALWAYS_COND]
        List of touple containg of starting and ending indices of [ALWAYS_BLOCK:] and [:ALWAYS_BLOCK] 
    Raises: No exception
    """
    #if(DBG): print "---extr_always_blocks"
    l_text = []
    l_index = []

    with open(input_list, "r") as f:
        for line in f:
            #if(DBG): print line
            l_s_always_cond = ([m.start() for m in re.finditer('\[ALWAYS_COND:\]', line)])
            l_e_always_cond = ([m.start() for m in re.finditer('\[:ALWAYS_COND\]', line)])
            l_s_always_block = ([m.start() for m in re.finditer('\[ALWAYS_BLOCK:\]', line)])
            l_e_always_block = ([m.start() for m in re.finditer('\[:ALWAYS_BLOCK\]', line)]) 
    with open(input_list, "r") as f:
        for line in f:
            #if(DBG): print line
            for i in range(len(l_s_always_cond)):
                l_text.append (line[l_s_always_cond[i]+14 : l_e_always_cond[i]])
                l_index.append((l_s_always_block[i]+16, l_e_always_block[i]))
    l_index_o, l_text_tmp = index_reorder (l_index, l_text) 
    l_text_o = remove_labels(l_text_tmp) 
    return l_text_o, l_index_o

def extr_for_blocks(text):
    """Extract the blocks between [FOR_BLOCK:] and [:FOR_BLOCK]
    Args:
        text: The output obtained by parsing quteRTL output using Antlr
    Returns: 
        List of sections between [FOR_COND:] and [:FOR_COND]
        List of touple containg of starting and ending indices of [FOR_BLOCK:] and [:FOR_BLOCK] 
    Raises: No exception
    """
    #if(DBG): print "---extr_for_blocks"
    l_text = []
    l_index = []

    with open(input_list, "r") as f:
        for line in f:
            #if(DBG): print line
            l_s_for_cond = ([m.start() for m in re.finditer('\[FOR_COND:\]', line)])
            l_e_for_cond = ([m.start() for m in re.finditer('\[:FOR_COND\]', line)])
            l_s_for_block = ([m.start() for m in re.finditer('\[FOR_BLOCK:\]', line)])
            l_e_for_block = ([m.start() for m in re.finditer('\[:FOR_BLOCK\]', line)]) 
    with open(input_list, "r") as f:
        for line in f:
            #if(DBG): print line
            for i in range(len(l_s_for_cond)):
                l_text.append (line[l_s_for_cond[i]+11 : l_e_for_cond[i]])
                l_index.append((l_s_for_block[i]+13, l_e_for_block[i]))
    l_index_o, l_text_tmp = index_reorder (l_index, l_text) 
    l_text_o = remove_labels(l_text_tmp) 
    return l_text_o, l_index_o

def extr_nb_assigns(text):
    """Extract the blocks between [NB_ASSIGN:] and [:NB_ASSIGN]
    Args:
        text: The output obtained by parsing quteRTL output using Antlr
    Returns: 
        List of sections between [RSIDE:] and [:RSIDE]
        List of touple containg of starting and ending indices of [NB_ASSIGN:] and [:NB_ASSIGN] 
    Raises: No exception
    """
    #if(DBG): print "---extr_nb_assigns"
    l_text = []
    l_index = []
    l_s_nb_assign_cond = [] 
    l_e_nb_assign_cond = []
    l_s_nb_assign = []
    l_e_nb_assign = []  

    with open(input_list, "r") as f:
        for line in f:
            #if(DBG): print line
            l_s_nb_assign_cond = ([m.start() for m in re.finditer('\[RSIDE:\]', line)])
            l_e_nb_assign_cond = ([m.start() for m in re.finditer('\[:RSIDE\]', line)])
            l_s_nb_assign = ([m.start() for m in re.finditer('\[NB_ASSIGN:\]', line)])
            l_e_nb_assign = ([m.start() for m in re.finditer('\[:NB_ASSIGN\]', line)]) 
            # Check whether you need NB_ASSIGN or LSIDE here. Same with if, case etc. --vineeshvs (1-Mar-2019)
            #l_s_nb_assign = ([m.start() for m in re.finditer('\[LSIDE:\]', line)])
            #l_e_nb_assign = ([m.start() for m in re.finditer('\[:LSIDE\]', line)]) 
    #if(DBG): print "l_s_nb_assign_cond: ", l_s_nb_assign_cond 
    #if(DBG): print "l_e_nb_assign_cond: ", l_e_nb_assign_cond
    #if(DBG): print "l_s_nb_assign: ", l_s_nb_assign
    #if(DBG): print "l_e_nb_assign: ", l_e_nb_assign  
    #if(DBG): print "len(l_s_nb_assign_cond): ", len(l_s_nb_assign_cond)
    #if(DBG): print "len(l_e_nb_assign_cond): ", len(l_e_nb_assign_cond)
    #if(DBG): print "len(l_s_nb_assign): ", len(l_s_nb_assign)
    #if(DBG): print "len(l_e_nb_assign): ", len(l_e_nb_assign)  
    with open(input_list, "r") as f:
        for line in f:
            #if(DBG): print line
            for i in range(len(l_s_nb_assign_cond)):
                l_text.append (line[l_s_nb_assign_cond[i]+8 : l_e_nb_assign_cond[i]])
                #if(DBG): print "Influencer text segment: ", line[l_s_nb_assign_cond[i]+8 : l_e_nb_assign_cond[i]]
                #if(DBG): print "l_s_nb_assign[i]: ", l_s_nb_assign[i]
                #if(DBG): print "l_s_nb_assign[i]: ", l_s_nb_assign[i]
                #if(DBG): print "l_e_nb_assign[i]: ", l_e_nb_assign[i]
                l_index.append((l_s_nb_assign[i]+12, l_e_nb_assign[i]))
                #if(DBG): print "Influencer text index: ", (l_s_nb_assign[i]+12, l_e_nb_assign[i])
    #if(DBG): print "l_index: ", l_index
    #if(DBG): print "l_text: ", l_text
    l_index_o, l_text_tmp = index_reorder (l_index, l_text) 
    l_text_o = remove_labels(l_text_tmp) 
    #if(DBG): print "l_index_o: ", l_index_o
    #if(DBG): print "l_text_tmp: ", l_text_tmp
    #if(DBG): print "l_text_o: ", l_text_o
    #if(DBG): print "len(l_index_o): ", len(l_index_o)
    #if(DBG): print "len(l_text_o): ", len(l_text_o)
    return l_text_o, l_index_o

def extr_ba_nba_sigs(text):
    """ Extracts the signals inside a ba_nba block. Extracts valid signals as per Verilog standards.
        Comments: Verlog doens't allow allow signals to start with a number.
        It doens't return constant values.
    Args:
        text: Part of the output from quteRTL parsing relevant to ba_nba block 
    Returns: A list of valid Verilog signals in 'text'. 
    Raises: No exception
    """
    #if(DBG): print "---extr_ba_nba_sigs: "
    pat = re.compile(r'[\w\']+') 
    l_t = re.findall(pat, text)
    l_o = []
    #if(DBG): print l_t
    for item in l_t:
        #if(DBG): print item
        if re.match(r'[a-zA-Z](.*)', str(item)):
        #if re.match(r'(.*)\((.*)\)', str(item)): TODO
            l_o.append(item)
    return l_o

def extr_sigs(text):
    """ Extracts signals from a string. Extracts valid signals as per Verilog standards.
        It doens't return constant values.
    Args:
        text: Part of the output from quteRTL parsing relevant to various blocks (Eg: if_block).
    Returns: A list of valid Verilog signals in 'text'. 
    Raises: No exception
    Comments: Verlog doesn't allow allow signals to start with a number.
    """
    #if(DBG): print "---extr_sigs"
    pat = re.compile(r'[\w\']+') 
    l_t = re.findall(pat, text)
    l_o = []
    #if(DBG): print "Input text: ",  l_t
    #if(DBG): print "First level pattern match: ",  l_t
    # Removing signals start with anything other than [a-zA-Z]
    for item in l_t:
        #if(DBG): print item
        if re.match(r'[a-zA-Z](.*)', str(item)):
            #if(DBG): print "Second level pattern match: ",  item.strip()
            l_o.append(item.strip())
    return l_o

def remove_labels(l_text):
    """ Removes the strings inside '[]' along with the braces
    Args:
        l_text: List of strings
    Returns:
        l_out: Output list with sections of the format "[<anything>]" removed.
    Raises: No exception
    """
    #if(DBG): print "---remove_labels"
    #if(DBG): print "IN: ", l_text
    l_out = []
    f_tmp = 1
    f_wr = 0
    i = 0
    for item in l_text:
        l_out.append('')
        for char in item:
            if char == "[":
                f_tmp = 0
            if f_tmp:
                f_wr = 1
            else:
                f_wr = 0 
            if f_wr == 1:
                l_out[i] += char
            if char == "]":
                f_tmp = 1
        i+=1
    #if(DBG): print "OUT: ", strip_space(l_out)
    return strip_space(l_out)

def strip_space(i_list):
    """Strip whitespace from all elements of a list
    Args:
        i_list: input list
    Returns
        List with elements without any space anywhere.
    Raises: No error
    """
    o_list = []
    for i in range(len(i_list)):
        o_list.append(i_list[i].strip())
    return o_list

def index_reorder(l_index, l_text):
    """ Reorders the index of the start and end of blocks (Eg: IF_BLOCK)
        to ensure that the start and end indices are correct when there 
        are nested blocks.
    Args:
         l_index: The list of touples containing the start and end of blocks.
            It will have wrong indices when there are nested blocks.
    Returns: 
        List of touples with correct indices.
    Raises: No exception.
    """
    # TODO[Low priority] This function can be improved for speed.
    #if(DBG): print "---index_reorder"
    l_tmp = []
    
    l_index_tmp = list(l_index)
    l_text_tmp = list(l_text)
    # Reverse the elements of the tuple in the input list
    for i in range(len(l_index_tmp)):
        tmp1 = l_index_tmp[i][0]
        tmp1 = l_index_tmp[i][1]
        l_index_tmp[i] = ((l_index_tmp[i][1], l_index_tmp[i][0]))
    l_index_o = list(l_index)
    #if(DBG): print "l_index_tmp: ", l_index_tmp
    for i in range(len(l_index_tmp)):
        end = l_index_tmp[i][0]
        del l_tmp[:]
        #------------------------------------------------------------------
        # Get the indices of all the start addresses which are less than end.
        # Add those along with the actual index in l_index_tmp to l_tmp.
        #------------------------------------------------------------------
        for j in range(len(l_index_tmp)):
            if l_index_tmp[j][1] < end:
                l_tmp.append((j, l_index_tmp[j][1]))
        #if(DBG): print "\nend: ", end
        #if(DBG): print "l_tmp: ", l_tmp
        # Find out the largest number in l_tmp (which corresponds to the closest -
        # start of the block) and its position in l_index_tmp.
        #-----------------------------------
        tmp = -1
        for k in range(len(l_tmp)):
            if l_tmp[k][1] > tmp:
                tmp = l_tmp[k][1]
                highest_index = l_tmp[k][0]
        #if(DBG): print "highest_index: ", highest_index   
        #-----------------------------------
        # Add the end value to the tuple with the actual start value.
        l_index_o[i] = ((end, l_tmp[highest_index][1]))
        #if(DBG): print "start: ", l_tmp[highest_index][1]
        # To ensure that the current start of the block is not considered again
        l_index_tmp[highest_index] = ((l_index_tmp[highest_index][0], -1))
        # Reordering l_text
        l_text[i] = l_text_tmp[highest_index]
        #if(DBG): print "l_index_tmp_UPDATED: ", l_index_tmp
        #if(DBG): print "l_index_o_UPDATED: ", l_index_o
        #if(DBG): print "l_text_UPDATED: ", l_text
        #------------------------------------------------------------------
    # Reverse the elements of the tuple in the output list
    for i in range(len(l_index_o)):
        tmp1 = l_index_o[i][0]
        tmp1 = l_index_o[i][1]
        l_index_o[i] = ((l_index_o[i][1], l_index_o[i][0]))
    #------------------------------------------------------------------
    # Delete later
    #------------------------------------------------------------------
    # Reverse the elements of the tuple in the input list
    for i in range(len(l_index_tmp)):
        tmp1 = l_index_tmp[i][0]
        tmp1 = l_index_tmp[i][1]
        l_index_tmp[i] = ((l_index_tmp[i][1], l_index_tmp[i][0]))
    #if(DBG): print "l_index_FINAL: ", l_index_tmp
    #if(DBG): print "l_index_o_FINAL: ", l_index_o
    #------------------------------------------------------------------
    # Reverse the elements of the tuple in the input list
    return l_index_o, l_text

def get_overlapping_indices(l_outer, l_inner):
    """ Find out the overlapping tuples in the two lists
    Args:
        l_outer: List 1 (Eg: With indices of if_block)
        l_inner: List 2 (Eg: With indices of ba_nba block)
    Returns:
        l_overlap: List of tuples with indices of tuples in the input list wherever there is overlap
            Eg: [(1,2)] -> Says that l_inner[1] and l_outer[2] has overlap.
    Raises: No error
    """
    #if(DBG): print "---get_overlapping_indices"
    l_overlap = []
    #if(DBG): print 'Overlap check for:'
    #if(DBG): print 'l_outer', l_outer
    #if(DBG): print 'l_inner', l_inner
    for i in range(len(l_inner)):
        for j in range(len(l_outer)):
            #if(DBG): print "l_inner[i]: ", l_inner[i], " l_outer[j]: ", l_outer[j]
            if l_inner[i][0] > l_outer[j][0]:
                #if(DBG): print "Start index match"
                if l_inner[i][1] < l_outer[j][1]:
                    #if(DBG): print "Overlap found in: ", l_inner[i], l_outer[j]
                    l_overlap.append((i,j))
    #if(DBG): print 'l_overlap', l_overlap
    return l_overlap

def print_file(input_file):
    """ print the contents of a file
    """
    with open(input_file, "r") as f:
        for line in f:
            if(DBG): print line

if __name__ == '__main__':
    main(sys.argv)
